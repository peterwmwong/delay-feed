<!DOCTYPE html>
<html>

<head>
    <title>delay feed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html,
        body {
            position: relative;
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background: black;
            font-family: sans-serif;
            font-size: 14px;
        }

        #liveFeed,
        #delayedFeedVideo {
            position: absolute;
        }

        #delayedFeedVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #liveFeed {
            bottom: 72px;
            right: 12px;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
            background-color: rgba(0, 0, 0, 0.5);
            width: 33%;
            overflow: hidden;
        }

        #liveFeedVideo {
            position: absolute;
        }

        #liveFeedCaption {
            color: white;
            position: relative;
            background-color: rgba(255, 0, 0, 0.5);
            text-align: center;
            position: absolute;
            width: 100%;
            bottom: 0;
            opacity: 0.75;
        }

        .mirror {
            transform: scaleX(-1);
        }

        video.mirror::-webkit-media-controls,
        .mirror video::-webkit-media-controls {
            transform: scaleX(-1);
        }
    </style>
</head>

<body onclick="document.body.requestFullscreen({ navigationUI: 'hide' });">
    <video id="delayedFeedVideo" class="mirror" autoplay controls></video>
    <div id="liveFeed">
        <div class="mirror">
            <video id="liveFeedVideo" autoplay></video>
        </div>
        <div id="liveFeedCaption">Live</div>
    </div>
    <script type="module">
        const waitForSettings = (stream) => new Promise((resolve) => {
            const check = () => {
                const settings = stream.getVideoTracks()[0].getSettings();
                if (settings.width && settings.height) {
                    resolve(settings);
                } else {
                    window.requestAnimationFrame(check)
                }
            };
            check();
        });
        try {
            const DELAY_S = 2;
            const DELAY_MS = DELAY_S * 1000;
            const { delayedFeedVideo, liveFeedVideo, liveFeed } = window;
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: Math.max(screen.width, screen.height) * 2 },
                    height: { ideal: Math.min(screen.width, screen.height) * 2 },
                    frameRate: { ideal: 60 },
                    aspectRatio: { ideal: 1.777777777 }
                }
            });
            liveFeedVideo.srcObject = stream;
            const { width, height } = await waitForSettings(stream);
            liveFeed.style.aspectRatio = width / height;

            const resizeliveFeedVideo = () => {
                const tx = liveFeed.clientWidth / width;
                liveFeedVideo.style.transform = `scale(${tx})`;
                liveFeedVideo.style.transformOrigin = 'top left';
            }
            window.onresize = resizeliveFeedVideo;
            resizeliveFeedVideo();

            const mediaSource = new MediaSource();
            delayedFeedVideo.src = URL.createObjectURL(mediaSource);
            mediaSource.addEventListener('sourceopen', () => {
                const mimeType = [
                    'video/webm; codecs="vp8"', // Performs much better than vp9 on Pixel 3
                    'video/mp4; codecs="avc1"'  // Safari
                ].find(t => MediaRecorder.isTypeSupported(t));
                const recorder = new MediaRecorder(stream, { mimeType });
                const srcBuf = mediaSource.addSourceBuffer(mimeType);
                srcBuf.onupdate = () => {
                    const { buffered } = srcBuf;
                    if (buffered.length && buffered.end(0) - buffered.start(0) > DELAY_S * 6) {
                        srcBuf.remove(buffered.start(0), buffered.start(0) + DELAY_S);
                    }
                    delayedFeedVideo.play();
                };
                recorder.ondataavailable = async ({ data }) => {
                    const bytes = await data.arrayBuffer();
                    const update = () => srcBuf.appendBuffer(bytes);
                    if (srcBuf.updating) {
                        srcBuf.addEventListener('update', update(), { once: true })
                    } else {
                        update();
                    }
                };
                recorder.start(DELAY_MS);
            }, { once: true });
        } catch (e) { alert(e) };
    </script>
</body>

</html>